## Домашнее задание №4 «Выдача заказов в разной упаковке»
### Цель:

Модифицировать ваш сервис, добавить возможность в ПВЗ выдавать заказы в любой из трех различных упаковок

### Основное задание:

- **Модифицируйте Go-приложение**, добавьте в метод "Принять заказ от курьера" возможность передавать параметр упаковки
- Всего есть три вида упаковки: пакет, коробка, пленка
- Реализуйте функционал так, чтобы в будущем можно было просто добавить еще один вид упаковки
- При выборе пакета необходимо проверять, что вес заказа меньше 10 кг, если нет, то возвращаем информативную ошибку
- При выборе пакета стоимость заказа увеличивается на 5 рублей
- При выборе коробки необходимо проверить, что вес заказа меньше 30 кг, если нет, то возвращаем информативную ошибку
- При выборе коробки стоимость заказа увеличивается на 20 рублей
- При выборе пленки дополнительных проверок не требуется
- При выборе пленки стоимость заказа увеличивается на 1 рубль

### Дополнительное задание:

- Опишите архитектуру своего решения любым известным стандартом (например, UML)
- В MR вложите файл с описанием архитектуры
- При выборе стандарта необходимо описать, какой был выбран стандарт и дать ссылку на его документацию
- Запрещается использовать генерилки диаграмм, а также инструменты генерации связей между таблицами в БД в качестве описания

### Дедлайны сдачи и проверки задания:
- 22 июня 23:59 (сдача) / 25 июня, 23:59 (проверка)

## Выполнение дз

Код организован по неофициальным стандартам Go dev команды:
[](https://github.com/golang-standards/project-layout)
Были использованы Агрегация и Композиция, Model View Presenter.
Примеры шаблонов проектирования, которые были использованы:
- Repository
```
type Repository struct {
    *transactor.TransactionManager
}

func New(tm *transactor.TransactionManager) *Repository {
    return &Repository{tm}
}
```
- Factory
```
func NewOrder(orderID, userID int, deadline time.Time, totalCost float64) Order {
    return Order{
        OrderID: orderID,
        UserID: userID,
        Deadline: deadline,
        Cost: totalCost,
    }
}
```
- Dependency Injection
```
type Deps struct {
    Repository Repository
}

type Module struct {
    Deps
}

func New(d Deps) Module {
    return Module{Deps: d}
}
```
- Observer
```
func (c *CLI) Run() error {
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

    go func() {
        <-sigChan
        fmt.Println("Получен сигнал остановки. Ожидание завершения всех задач...")
        c.wg.Wait()
        fmt.Println("Все задачи завершены. Выход...")
        os.Exit(0)
    }()
}
```

### Схема баз данных
![Схема базы данных](pictures/oms.png)

### Архитектура
![Архитектура](pictures/architecture.png)